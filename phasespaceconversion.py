# -*- coding: utf-8 -*-
"""PhaseSpaceConversion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kqEjK_9a_mnI8IWgbZB-AAEgj0beCvP3
"""

from sympy import *
from IPython.display import display
import numpy as np


def pow_to_mul_sep2(expr):
    """
    https://groups.google.com/g/sympy/c/qaJGesRbX_0
    Convert integer powers to a list of the operators like a**2 => [a,a].
    """
    pows = expr.args 
    #print('pows')
    #print(pows)
    list_terms = []
    
    if len(pows)==0: # there is only a single operator, no product
      list_terms.append(expr)
    else:
        for term in pows:
          [op, n] = term.as_base_exp()
          for k in range(n):
            list_terms.append(op)

        #print(list_terms)
    return  list_terms

# Each term in the expanded master equation needs to be cleaned.


class PhaseSpaceFunction(object):
    def __init__(self, mastereq,field_type='W'):
        self.ME = mastereq


        #this is kind of lame that we need to redfine the symbols here if there are multiple
        self.rho = Symbol(r'\rho', commutative=False)
        
        self.a = Symbol(r'a', commutative=False)
        self.ad = Symbol(r'a^\dag', commutative=False)
        self.alpha = Symbol(r'\alpha')
        self.alphas = Symbol(r'\alpha^*')
        
        self.b = Symbol(r'b', commutative=False)
        self.bd = Symbol(r'b^\dag', commutative=False)
        self.beta = Symbol(r'\beta')
        self.betas = Symbol(r'\beta^*')
        
        self.field_type = field_type
        
        self.field = Function(field_type)(self.alpha,self.alphas,self.beta,self.betas) # can be W, Q or P

    def cleanTerm(self,term):
      # the dagger operators, if they are on LHS or RHS of rho, and the constant that precedes them.
      # take out rho to get the other constants"
      termNoRho = term.subs(self.rho,1 ) 

      # take out all a's
      termConsts = termNoRho
      while termConsts.has(self.a):
            termConsts = termConsts.subs(self.a,1 ) 
      while termConsts.has(self.ad):
            termConsts = termConsts.subs(self.ad,1 ) 
      while termConsts.has(self.b):
            termConsts = termConsts.subs(self.b,1 ) 
      while termConsts.has(self.bd):
            termConsts = termConsts.subs(self.bd,1 ) 

      #print('constants in term:')
      #display(termConsts)
      clean_term = term.subs(termConsts,1) 
      #display(clean_term)
      clean_termNoRho =  clean_term.subs(self.rho,1 )
      ordered_operators = pow_to_mul_sep2(clean_termNoRho)
      #print('test')
      #display(clean_termNoRho)
      #print(ordered_operators)
      # if rho is the first entry of this clean term, the operators must be on the RHS
      #print(cleanTerm.args)
      if clean_term.args[0]==self.rho:
        termtype = 'RHS'      
      elif clean_term.args[-1]==self.rho:
        termtype = 'LHS'
      else:
        'unable to determine term type'
      return termtype, ordered_operators, termConsts
    
    def getFPfromME(self):
      # get number of terms in the Master equation
      ME_termlist = self.ME.args
      n_terms = len(ME_termlist)
      #display(ME_termlist)
      field_terms = []
      
      if self.field_type=='W':
        s=0
      elif self.field_type =='Q':
        s=-1
      elif self.field_type =='P':
        s=+1
      else:
        print('not valid field type!')
        print(self.field_type)
        
      for j in range (n_terms): # loop over terms in ME
          print( "Term {} :".format(j)) 
          field_eqn = self.field # dummy 1st 
          term = ME_termlist[j] # select jth term from ME
          display(term)
          termtype, list_operators, termConsts = self.cleanTerm(term) # get operator list from term

          
          # Operators appear on LEFT SIDE of rho
          if termtype=='LHS':
            # must now run to list in reverse order!
            list_operators_rev = list(reversed(list_operators))
            print('LHS term, order operators applied:')
            print(list_operators_rev)
                
            for op in list_operators_rev:
              if op==self.a:
                field_eqn = self.alpha*field_eqn  - Rational(s-1, 2)*diff(field_eqn, self.alphas)
              elif op==self.ad:
                field_eqn = self.alphas*field_eqn - Rational(s+1, 2)*diff(field_eqn, self.alpha)
              elif op==self.b:
                field_eqn = self.beta*field_eqn  - Rational(s-1, 2)*diff(field_eqn, self.betas)
              elif op==self.bd:
                field_eqn = self.betas*field_eqn - Rational(s+1, 2)*diff(field_eqn, self.beta) 
              else:
                 print('error')
      
              # display(field_eqn)
          # Operators appear on RIGHT SIDE of rho
          if termtype=='RHS':
            print('RHS term, order operators applied:')
            print(list_operators)
            for op in list_operators:
              if op==self.a:
                field_eqn = self.alpha*field_eqn  - Rational(s+1, 2)*diff(field_eqn, self.alphas)
              elif op==self.ad:
                field_eqn = self.alphas*field_eqn - Rational(s-1, 2)*diff(field_eqn, self.alpha)
              elif op==self.b:
                  field_eqn = self.beta*field_eqn  - Rational(s+1, 2)*diff(field_eqn, self.betas)
              elif op==self.bd:
                  field_eqn = self.betas*field_eqn - Rational(s-1, 2)*diff(field_eqn, self.beta)
                
              else:
                'error'
              # display(field_eqn)

          field_eqn = termConsts*field_eqn

          field_terms.append(field_eqn)
          display(field_eqn)

      field_eqn_final = np.sum(field_terms)
      field_eqn_final=simplify(field_eqn_final) 
      #substitute absolute value (since they are used as separate variables cannot do this before):

      for k in range(3): #!! TODO
        field_eqn_final = field_eqn_final.subs(self.alpha*self.alphas,Abs(self.alpha**2))
        field_eqn_final = field_eqn_final.subs(self.alphas*self.alpha,Abs(self.alpha**2))

      return field_eqn_final

    