# -*- coding: utf-8 -*-
"""PhaseSpaceConversion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kqEjK_9a_mnI8IWgbZB-AAEgj0beCvP3
"""

from sympy import *
from IPython.display import display
import numpy as np


def pow_to_mul_sep2(expr):
    """
    https://groups.google.com/g/sympy/c/qaJGesRbX_0
    Convert integer powers to a list of the operators like a**2 => [a,a].
    """
    pows = expr.args 
    #print('pows')
    #print(pows)
    list_terms = []
    
    if len(pows)==0: # there is only a single operator, no product
      list_terms.append(expr)
      
    elif pows[1].is_integer:
         for k in range(pows[1]):
            op = pows[0]
            list_terms.append(op)
        
    else:
        for term in pows:
          [op, n] = term.as_base_exp()
          for k in range(n):
            list_terms.append(op)

        #print(list_terms)
    return  list_terms

def getPosRho(clean_term,rho): # this takes into account the squares!!
    counter=0
    items= clean_term.args
    n_items = len(items)
    print(items)
    for k in range(n_items):
        item = items[k]
        if item==rho:
           break    # break here
        else:
            [op, n] = item.as_base_exp()
            counter = counter+n
            print(counter)

    print('rho occurs on position  {}'.format(counter))
    return counter

def getOperators(clean_term,pos_rho,pos='before'): # this takes into account the squares!!
    counter=0
    items= clean_term.args
    n_items = len(items)
    operators = []
    print(items)
    for k in range(pos_rho):
        item = items[k]
        if item==rho:
           break    # break here
        else:
            [op, n] = item.as_base_exp()
            counter = counter+n
            print(counter)

    print('rho occurs on position  {}'.format(counter))
    return counter

def getPosRhoList(clean_term,rho): # this takes into account the squares!!
    counter=0
    items= clean_term.args
    n_items = len(items)
    print(items)
    for k in range(n_items):
        item = items[k]
        if item==rho:
           break    # break here
        else:
            counter = counter+1
            print(counter)

    print('rho occurs on position  {}'.format(counter))
    return counter

def labelOperators(ordered_operators, pos_rho):
    n_operators = len(ordered_operators)
    operator_labels = ['RHS']*n_operators
    operator_labels[:pos_rho]=['LHS']*pos_rho
    return operator_labels


# Each term in the expanded master equation needs to be cleaned.


class PhaseSpaceFunction(object):
    def __init__(self, mastereq,field_type='W',showDetails=True):
        self.ME = mastereq
        self.showDetails = showDetails

        #this is kind of lame that we need to redfine the symbols here if there are multiple
        self.rho = Symbol(r'\rho', commutative=False)
        
        self.a = Symbol(r'a', commutative=False)
        self.ad = Symbol(r'a^\dag', commutative=False)
        self.alpha = Symbol(r'\alpha')
        self.alphas = Symbol(r'\alpha^*')
        
        self.b = Symbol(r'b', commutative=False)
        self.bd = Symbol(r'b^\dag', commutative=False)
        self.beta = Symbol(r'\beta')
        self.betas = Symbol(r'\beta^*')
        
        self.field_type = field_type
        
        self.field = Function(field_type)(self.alpha,self.alphas,self.beta,self.betas) # can be W, Q or P

    def cleanTerm(self,term):
      # the dagger operators, if they are on LHS or RHS of rho, and the constant that precedes them.
      # take out rho to get the other constants"
      termNoRho = term.subs(self.rho,1 ) 

      # take out all a's
      termConsts = termNoRho
      while termConsts.has(self.a):
            termConsts = termConsts.subs(self.a,1 ) 
      while termConsts.has(self.ad):
            termConsts = termConsts.subs(self.ad,1 ) 
      while termConsts.has(self.b):
            termConsts = termConsts.subs(self.b,1 ) 
      while termConsts.has(self.bd):
            termConsts = termConsts.subs(self.bd,1 ) 

      #print('constants in term:')
      #display(termConsts)
      clean_term = term.subs(termConsts,1) 

      clean_termNoRho =  clean_term.subs(self.rho,1 )
        
      if self.showDetails: 
          display(clean_term)
          display(clean_termNoRho)

      if clean_term.args[0]==self.rho:
        # label all operators as RHS
        termtype = 'RHS'   
        ordered_operators = pow_to_mul_sep2(clean_termNoRho)
        n_operators = len(ordered_operators)
        operator_labels = ['RHS']*n_operators
      elif clean_term.args[-1]==self.rho:
        termtype = 'LHS'
        ordered_operators = pow_to_mul_sep2(clean_termNoRho)
        n_operators = len(ordered_operators)
        operator_labels = ['LHS']*n_operators
      else: # rho in the middle:
        termtype = 'MID'
        # pos_rho=getPosRho(clean_term,self.rho) # ! takes into account powers
        pos_rho=getPosRhoList(clean_term,self.rho) # does count the powers if there are terms iwth powers
        # split in two sets of operators, before and after, so they can
        # be applied in order separately:
        
        operators_before = clean_term.args[:pos_rho][0]
         # deal with powers
        ordered_operators_before = pow_to_mul_sep2(operators_before) # remove powers
        # else:
        #     ordered_operators_before = operators_before 
        # operator_labels_before = ['LHS']*len(ordered_operators_before)
        
        operators_after = clean_term.args[(pos_rho+1):][0]
        ordered_operators_after = pow_to_mul_sep2(operators_after) # remove powers
    
          

        # operator_labels_after = ['RHS']*len(ordered_operators_after)
            
        # operator_labels=labelOperators(ordered_operators, pos_rho)
        ordered_operators = [ordered_operators_before,ordered_operators_after]
        # operator_labels=[operator_labels_before,operator_labels_after]
    
      
      # n_operators = len(ordered_operators)
        #print('test')
        #display(clean_termNoRho)
        #print(ordered_operators)
    # if rho is the first entry of this clean term, the operators must be on the RHS
    #print(cleanTerm.args)
      # operator_labels =[] # label each individual operator in the list as RHS or LHS of Rho


        # print('Mid Term Type')
      return termtype, ordered_operators, termConsts
  
    def applyOperators(self,op, op_label,s):


              if op==self.a and op_label=='LHS':
                self.field_eqn = self.alpha*self.field_eqn  - Rational(s-1, 2)*diff(self.field_eqn, self.alphas)
              elif op==self.ad and  op_label=='LHS':
                self.field_eqn = self.alphas*self.field_eqn - Rational(s+1, 2)*diff(self.field_eqn, self.alpha)
              elif op==self.b and  op_label=='LHS':
                self.field_eqn = self.beta*self.field_eqn  - Rational(s-1, 2)*diff(self.field_eqn, self.betas)
              elif op==self.bd and  op_label=='LHS':
                self.field_eqn = self.betas*self.field_eqn - Rational(s+1, 2)*diff(self.field_eqn, self.beta) 
     
              # RHS TERMS
              elif op==self.a and  op_label=='RHS':
                self.field_eqn = self.alpha*self.field_eqn  - Rational(s+1, 2)*diff(self.field_eqn, self.alphas)
              elif op==self.ad and  op_label=='RHS':
                self.field_eqn = self.alphas*self.field_eqn - Rational(s-1, 2)*diff(self.field_eqn, self.alpha)
              elif op==self.b and  op_label=='RHS':
                  self.field_eqn = self.beta*self.field_eqn  - Rational(s+1, 2)*diff(self.field_eqn, self.betas)
              elif op==self.bd and  op_label=='RHS':
                  self.field_eqn = self.betas*self.field_eqn - Rational(s-1, 2)*diff(self.field_eqn, self.beta)
                
              else:
                print('error op not found')
                print(op)
                print(op_label)
                
                
              return self.field_eqn
    
    def getFPfromME(self):
      # get number of terms in the Master equation
      ME_termlist = self.ME.args
      n_terms = len(ME_termlist)
      display(ME_termlist)
      field_terms = []
      
      if self.field_type=='W':
        s=0
      elif self.field_type =='Q':
        s=-1
      elif self.field_type =='P':
        s=+1
      else:
        print('not valid field type!')
        print(self.field_type)
        
      for j in range (n_terms): # loop over terms in ME
          self.field_eqn = self.field # dummy 1st 
          term = ME_termlist[j] # select jth term from ME
          display(term)
            # get operator list from term
          termtype, list_operators, termConsts = self.cleanTerm(term) 
          # each operator is marked to be on the rhs or lhs of rho. 

          if termtype =='MID':
             printop ='MID term'
             for j in range(2):
                 list_operators_j = list_operators[j]
                 print('j=')
                 print(j)
                 if j == 0: 
                        #termtype=='LHS':
                       op_label = 'LHS'
                       # must now run to list in reverse order!
                       list_operators_j= list(reversed(list_operators_j))
                       n_operators = len(list_operators_j)
                       operator_labels_j = ['LHS']*n_operators
                       printop = 'ops left in mid term, order operators applied:'
                 else:
                       op_label = 'RHS'
                       printop = 'ops right in mid term, order operators applied:'
                       operator_labels_j = ['RHS']*n_operators
                       
                 if self.showDetails: 
                    print( "Term {} :".format(j)) 
                    print(printop)
                    print(list_operators_j)  
                    display(self.field_eqn)
                   
                 n_operators_j = len(list_operators_j)
                 for k in range(n_operators_j):
                      op = list_operators_j[k]
                      op_label = operator_labels_j[k]
                      self.field_eqn = self.applyOperators(op,op_label,s)
                      display(self.field_eqn)
          else:
              # Operators appear on LEFT SIDE of rho
              if termtype=='LHS':
                op_label = 'LHS'
                # must now run to list in reverse order!
                list_operators= list(reversed(list_operators))
                printop = 'LHS term, order operators applied:'
              elif termtype=='RHS':
                op_label = 'RHS'
                printop = 'RHS term, order operators applied:'
    
              else:
                printop ='no defined'
            
              n_operators = len(list_operators)
              for k in range(n_operators):
                  op = list_operators[k]
                  op_label_k = op_label
                  self.field_eqn = self.applyOperators(op,op_label_k,s)


              # display(self.field_eqn)

          self.field_eqn = termConsts*self.field_eqn

          field_terms.append(self.field_eqn)
            
          if self.showDetails: 
              print( "Term {} :".format(j)) 
              print(printop)
              print(list_operators)  
              display(self.field_eqn)

      self.field_eqn_final = np.sum(field_terms)
      self.field_eqn_final=simplify(self.field_eqn_final) 
      #substitute absolute value (since they are used as separate variables cannot do this before):

      for k in range(3): #!! TODO
        self.field_eqn_final = self.field_eqn_final.subs(self.alpha*self.alphas,Abs(self.alpha**2))
        self.field_eqn_final = self.field_eqn_final.subs(self.alphas*self.alpha,Abs(self.alpha**2))

      return self.field_eqn_final
