# -*- coding: utf-8 -*-
"""PhaseSpaceConversion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kqEjK_9a_mnI8IWgbZB-AAEgj0beCvP3
"""

from sympy import *
from IPython.display import display
import numpy as np


def pow_to_mul_sep2(expr):
    """
    https://groups.google.com/g/sympy/c/qaJGesRbX_0
    Convert integer powers to a list of the operators like a**2 => [a,a].
    """
    pows = expr.args 
    #print('pows')
    #print(pows)
    list_terms = []
    
    if len(pows)==0: # there is only a single operator, no product
      list_terms.append(expr)
    else:
        for term in pows:
          [op, n] = term.as_base_exp()
          for k in range(n):
            list_terms.append(op)

        #print(list_terms)
    return  list_terms

def getPosRho(clean_term,rho):
    counter=0
    items= clean_term.args
    n_items = len(items)
    print(items)
    for k in range(n_items):
        item = items[k]
        if item==rho:
           break    # break here
        else:
            [op, n] = item.as_base_exp()
            counter = counter+n
            print(counter)

    print('rho occurs on position  {}'.format(counter))
    return counter

def labelOperators(ordered_operators, pos_rho):
    n_operators = len(ordered_operators)
    operator_labels = ['RHS']*n_operators
    operator_labels[:pos_rho]=['LHS']*pos_rho
    return operator_labels


# Each term in the expanded master equation needs to be cleaned.


class PhaseSpaceFunction(object):
    def __init__(self, mastereq,field_type='W'):
        self.ME = mastereq


        #this is kind of lame that we need to redfine the symbols here if there are multiple
        self.rho = Symbol(r'\rho', commutative=False)
        
        self.a = Symbol(r'a', commutative=False)
        self.ad = Symbol(r'a^\dag', commutative=False)
        self.alpha = Symbol(r'\alpha')
        self.alphas = Symbol(r'\alpha^*')
        
        self.b = Symbol(r'b', commutative=False)
        self.bd = Symbol(r'b^\dag', commutative=False)
        self.beta = Symbol(r'\beta')
        self.betas = Symbol(r'\beta^*')
        
        self.field_type = field_type
        
        self.field = Function(field_type)(self.alpha,self.alphas,self.beta,self.betas) # can be W, Q or P

    def cleanTerm(self,term):
      # the dagger operators, if they are on LHS or RHS of rho, and the constant that precedes them.
      # take out rho to get the other constants"
      termNoRho = term.subs(self.rho,1 ) 

      # take out all a's
      termConsts = termNoRho
      while termConsts.has(self.a):
            termConsts = termConsts.subs(self.a,1 ) 
      while termConsts.has(self.ad):
            termConsts = termConsts.subs(self.ad,1 ) 
      while termConsts.has(self.b):
            termConsts = termConsts.subs(self.b,1 ) 
      while termConsts.has(self.bd):
            termConsts = termConsts.subs(self.bd,1 ) 

      #print('constants in term:')
      #display(termConsts)
      clean_term = term.subs(termConsts,1) 
      display(clean_term)
      clean_termNoRho =  clean_term.subs(self.rho,1 )
      display(clean_termNoRho)
      ordered_operators = pow_to_mul_sep2(clean_termNoRho)
      n_operators = len(ordered_operators)
      #print('test')
      #display(clean_termNoRho)
      #print(ordered_operators)
      # if rho is the first entry of this clean term, the operators must be on the RHS
      #print(cleanTerm.args)
      operator_labels =[] # label each individual operator in the list as RHS or LHS of Rho
      
      if clean_term.args[0]==self.rho:
        # label all operators as RHS
        termtype = 'RHS'   
        operator_labels = ['RHS']*n_operators
      elif clean_term.args[-1]==self.rho:
        termtype = 'LHS'
        operator_labels = ['LHS']*n_operators
      else: # rho in the middle:
        termtype = 'MID'
        pos_rho=getPosRho(clean_term,self.rho)
        operator_labels=labelOperators(ordered_operators, pos_rho)

        print('unable to determine term type')
      return termtype, ordered_operators,operator_labels, termConsts
    
    def getFPfromME(self):
      # get number of terms in the Master equation
      ME_termlist = self.ME.args
      n_terms = len(ME_termlist)
      display(ME_termlist)
      field_terms = []
      
      if self.field_type=='W':
        s=0
      elif self.field_type =='Q':
        s=-1
      elif self.field_type =='P':
        s=+1
      else:
        print('not valid field type!')
        print(self.field_type)
        
      for j in range (n_terms): # loop over terms in ME
          print( "Term {} :".format(j)) 
          field_eqn = self.field # dummy 1st 
          term = ME_termlist[j] # select jth term from ME
          display(term)
          termtype, list_operators,operator_labels, termConsts = self.cleanTerm(term) # get operator list from term
          n_operators = len(list_operators)
          
          # Operators appear on LEFT SIDE of rho
          if termtype=='LHS':
            # must now run to list in reverse order!
            list_operators= list(reversed(list_operators))
            print('LHS term, order operators applied:')
          elif termtype=='RHS':
            print('RHS term, order operators applied:')
          print(list_operators)    

          for k in range(n_operators):
              op = list_operators[k]
              op_label = operator_labels[k]

              if op==self.a and op_label=='LHS':
                field_eqn = self.alpha*field_eqn  - Rational(s-1, 2)*diff(field_eqn, self.alphas)
              elif op==self.ad and  op_label=='LHS':
                field_eqn = self.alphas*field_eqn - Rational(s+1, 2)*diff(field_eqn, self.alpha)
              elif op==self.b and  op_label=='LHS':
                field_eqn = self.beta*field_eqn  - Rational(s-1, 2)*diff(field_eqn, self.betas)
              elif op==self.bd and  op_label=='LHS':
                field_eqn = self.betas*field_eqn - Rational(s+1, 2)*diff(field_eqn, self.beta) 
     
              # RHS TERMS
              elif op==self.a and  op_label=='RHS':
                field_eqn = self.alpha*field_eqn  - Rational(s+1, 2)*diff(field_eqn, self.alphas)
              elif op==self.ad and  op_label=='RHS':
                field_eqn = self.alphas*field_eqn - Rational(s-1, 2)*diff(field_eqn, self.alpha)
              elif op==self.b and  op_label=='RHS':
                  field_eqn = self.beta*field_eqn  - Rational(s+1, 2)*diff(field_eqn, self.betas)
              elif op==self.bd and  op_label=='RHS':
                  field_eqn = self.betas*field_eqn - Rational(s-1, 2)*diff(field_eqn, self.beta)
                
              else:
                print('error')
              # display(field_eqn)

          field_eqn = termConsts*field_eqn

          field_terms.append(field_eqn)
          display(field_eqn)

      field_eqn_final = np.sum(field_terms)
      field_eqn_final=simplify(field_eqn_final) 
      #substitute absolute value (since they are used as separate variables cannot do this before):

      for k in range(3): #!! TODO
        field_eqn_final = field_eqn_final.subs(self.alpha*self.alphas,Abs(self.alpha**2))
        field_eqn_final = field_eqn_final.subs(self.alphas*self.alpha,Abs(self.alpha**2))

      return field_eqn_final

    